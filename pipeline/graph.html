<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Peer Review Quality Analysis - Visualization Dashboard</title>
    <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" type="text/css" href="./static/graph.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@latest"></script>
    <style>
        /* Professional styling overrides */
        .pipeline-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .pipeline-header h1 {
            margin: 0;
            font-size: 1.6em;
            font-weight: 600;
        }
        .pipeline-header a {
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 6px;
            transition: all 0.3s;
            font-weight: 500;
        }
        .pipeline-header a:hover {
            background: rgba(255,255,255,0.3);
            transform: translateX(-3px);
        }
        .data-info {
            text-align: center;
            padding: 12px 20px;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-radius: 8px;
            margin: 0 auto 25px auto;
            max-width: 700px;
            font-size: 0.95em;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
        }
        .section-title {
            text-align: center;
            color: #333;
            font-size: 1.4em;
            margin: 30px 0 15px 0;
            font-weight: 600;
        }
        .section-description {
            text-align: center;
            max-width: 900px;
            margin: 0 auto 25px auto;
            padding: 15px 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            line-height: 1.7;
            color: #555;
        }
        .section-description strong {
            color: #333;
        }
        .legend-box {
            display: flex;
            justify-content: center;
            gap: 25px;
            flex-wrap: wrap;
            margin: 15px 0;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.1);
        }
        .note-text {
            font-size: 0.85em;
            color: #777;
            font-style: italic;
        }
    </style>
</head>
<body>
  <!-- Header -->
  <div class="pipeline-header">
    <h1>üìä Peer Review Quality Analysis Dashboard</h1>
    <a href="/">‚Üê Back to Pipeline</a>
  </div>
  
  <!-- Data Status -->
  <div class="data-info" id="data-info">
    <span id="loading-text">‚è≥ Loading data...</span>
    <div id="loading-progress" style="display:none; margin-top:8px;">
      <div style="width:100%; height:6px; background:#e0e0e0; border-radius:3px; overflow:hidden;">
        <div id="progress-bar" style="width:0%; height:100%; background:linear-gradient(90deg, #667eea, #764ba2); transition:width 0.3s;"></div>
      </div>
    </div>
  </div>

  <h1 style="display:none;">Review Engagement Graph</h1>
  
  <!-- Section: Network Graph -->
  <h2 class="section-title">üîó Review Engagement Network</h2>
  <div class="section-description">
    <strong>Network Visualization:</strong> Each node represents a student reviewer. 
    Arrows indicate review relationships (reviewer ‚Üí author).<br>
    <strong>Node Size:</strong> Review participation rate (completed assignments / assigned assignments).<br>
    <strong>Node Color:</strong> Quality score intensity based on the selected metric below.
  </div>
  
  <!-- Mode Switch Buttons -->
  <div class="switch-bar">
    <button class="switch-btn active" onclick="window.updateGraphMode('all')">All Metrics</button>
    <button class="switch-btn" onclick="window.updateGraphMode('relevance')">Relevance</button>
    <button class="switch-btn" onclick="window.updateGraphMode('concreteness')">Concreteness</button>
    <button class="switch-btn" onclick="window.updateGraphMode('constructive')">Constructive</button>
  </div>

  <!-- Legend -->
  <div class="legend-box">
    <div class="legend-item"><div class="legend-color" style="background:#73BEFF"></div> Complete (‚â•3 rounds)</div>
    <div class="legend-item"><div class="legend-color" style="background:#ff6b6b; border-style:dashed"></div> Incomplete (&lt;3 rounds)</div>
    <div class="legend-item"><span style="font-size:1.2em">‚óè</span> Large = High participation</div>
    <div class="legend-item"><span style="opacity:0.3">‚óè</span> Light = Low score | <span style="opacity:1">‚óè</span> Dark = High score</div>
  </div>

  <!-- Main Graph and Control Panel -->
  <div id="review-graph-container">
    <div class="floating-panel">
      <label for="hw-select" class="assignment-label">Assignment Filter</label>
      <button id="hw-apply-btn">Apply</button>
      <select id="hw-select" multiple size="5">
        <!-- Options will be dynamically generated by JavaScript -->
      </select>
    </div>
    <div id="review-graph"></div>
  </div>

  <!-- Section: Student Review Summary -->
  <h2 class="section-title">üìù Student Review Summary</h2>
  <div class="section-description">
    <strong>Review Summary:</strong> View each student's review activity organized by homework assignment.<br>
    <strong>üì§ Reviews Given:</strong> Comments this student wrote to review other students' work.<br>
    <strong>üì• Reviews Received:</strong> Feedback this student received from peer reviewers.<br>
    <strong>Quality Labels:</strong> 
    <span class="label-tag relevance">R</span> Relevance | 
    <span class="label-tag concreteness">C</span> Concreteness | 
    <span class="label-tag constructive">S</span> Constructive
  </div>
  
  <!-- Search and Filter Controls -->
  <div class="student-summary-section">
    <div class="summary-controls">
      <div class="search-box">
        <input type="text" id="studentSearch" placeholder="Search student ID..." />
      </div>
      <div class="filter-group">
        <select id="hwFilter">
          <option value="all">All Assignments</option>
        </select>
        <select id="sortBy">
          <option value="name">Sort by Name</option>
          <option value="reviews">Sort by Review Count</option>
          <option value="participation">Sort by Participation Rate</option>
        </select>
      </div>
    </div>
    
    <!-- Summary Statistics -->
    <div class="summary-stats" id="summaryStats">
      <div class="stat-card primary">
        <div class="stat-icon">üë•</div>
        <div class="stat-value" id="totalStudents">0</div>
        <div class="stat-label">Total Students</div>
      </div>
      <div class="stat-card success">
        <div class="stat-icon">üìù</div>
        <div class="stat-value" id="totalReviews">0</div>
        <div class="stat-label">Total Reviews</div>
      </div>
      <div class="stat-card info">
        <div class="stat-icon">üìä</div>
        <div class="stat-value" id="avgParticipation">0%</div>
        <div class="stat-label">Avg Participation</div>
      </div>
      <div class="stat-card warning">
        <div class="stat-icon">‚≠ê</div>
        <div class="stat-value" id="avgQuality">0%</div>
        <div class="stat-label">Avg Quality Score</div>
      </div>
    </div>
    
    <!-- Student Review List -->
    <div class="student-summary-container" id="studentSummaryContainer">
      <div class="loading-placeholder" style="text-align: center; padding: 40px; color: #666;">
        <div style="font-size: 48px; margin-bottom: 15px;">‚è≥</div>
        Loading student data...
      </div>
    </div>
  </div>

  <!-- Load graph functions from local static folder -->
  <script type="module">
    // Import graph functions from local static folder
    import { processReviewerData } from './static/graph_func.js';
    import { updateNetworkInstance } from './static/graph_3labelFunc.js';
    
    let currentMode = 'all';
    let rawData = null;
    let currentHW = [];

    // Color configuration for 4 levels (same as original)
    const colorConfig = {
        relevance: { 
            colors: ["#FFEEB7", "#FFD753", "#F1BC0D", "#D4A302"], 
            title: 'Relevance Score' 
        },
        concreteness: { 
            colors: ["#CFFFCA", "#95ED65", "#54AF23", "#327111"], 
            title: 'Concreteness Score' 
        },
        constructive: { 
            colors: ["#F1DCFF", "#C78EED", "#9444CA", "#590A8E"], 
            title: 'Constructive Score' 
        },
        all: {
            colors: ["#F0F0F0", "#E0E0E0", "#757575", "#424242"],
            title: 'Overall Performance Score'
        }
    };

    // Generate graph function (same logic as graph_3labelFunc.js)
    function generateGraph(rawData, mode, hwNames) {
        const container = document.getElementById('review-graph');
        if (!container) return;

        const { nodes, links } = processReviewerData(rawData, mode, hwNames);

        // Node size calculation - Assignment level participation rate
        const allCompletionRates = nodes.map(n => {
            const assignmentCount = n.feedbacks.length;
            const completedAssignments = n.feedbacks.filter(fb => fb !== "").length;
            return assignmentCount > 0 ? completedAssignments / assignmentCount : 0;
        });
        const sizeScale = (rate) => 15 + (rate * 35); // Range 15-50

        // Node styles
        const visNodes = nodes.map(n => {
            const assignmentCount = n.feedbacks.length;
            const completedAssignments = n.feedbacks.filter(fb => fb !== "").length;
            const completionRate = assignmentCount > 0 ? completedAssignments / assignmentCount : 0;
            
            const totalFeedbacks = n.feedbacks.filter(fb => fb !== "").length;
            let score;
            
            if (mode === 'all') {
                if (totalFeedbacks > 0) {
                    const relevanceScore = n.labelCounts.relevance / totalFeedbacks;
                    const concretenessScore = n.labelCounts.concreteness / totalFeedbacks;
                    const constructiveScore = n.labelCounts.constructive / totalFeedbacks;
                    score = (relevanceScore + concretenessScore + constructiveScore) / 3;
                } else {
                    score = 0;
                }
            } else {
                score = totalFeedbacks > 0 ? n.labelCounts[mode] / totalFeedbacks : 0;
            }
            
            // 4-level color calculation
            let color;
            if (score >= 0.75) color = colorConfig[mode].colors[3];
            else if (score >= 0.5) color = colorConfig[mode].colors[2];
            else if (score >= 0.25) color = colorConfig[mode].colors[1];
            else color = colorConfig[mode].colors[0];

            return {
                id: n.id,
                label: n.id,
                value: sizeScale(completionRate),
                color: { background: color, border: color },
                borderWidth: 0,
                shape: "dot",
                title: `Reviewer: ${n.id}\n${colorConfig[mode].title}: ${Math.round(score * 100)}%\nReview participation: ${Math.round(completionRate * 100)}%`
            };
        });

        // Edge styles
        const visEdges = links.map(e => ({
            from: e.from,
            to: e.to,
            color: { color: e.completedAll ? "#73BEFF" : "#ff6b6b", highlight: e.completedAll ? "#73BEFF" : "#ff6b6b" },
            dashes: !e.completedAll,
            arrows: "to",
            width: 1.5
        }));

        const data = { nodes: new vis.DataSet(visNodes), edges: new vis.DataSet(visEdges) };
        const options = {
            nodes: {
                scaling: {
                    min: 20,
                    max: 60,
                    label: { enabled: true, min: 12, max: 20 }
                }
            },
            edges: {
                arrowStrikethrough: false,
                selectionWidth: 3
            },
            physics: {
                stabilization: { iterations: 100, fit: true },
                barnesHut: {
                    gravitationalConstant: -2000,
                    springLength: 150,
                    damping: 0.5
                }
            },
            interaction: {
                hover: true,
                tooltipDelay: 200
            }
        };

        updateNetworkInstance(container, data, options, rawData);
    }

    // Update graph mode function
    function updateGraphMode(mode, hwNames = [...currentHW]) {
        if (!rawData) return;
        currentMode = mode;
        currentHW = [...hwNames];

        // Update button active state
        document.querySelectorAll('.switch-btn').forEach(btn => btn.classList.remove('active'));
        const modeButtons = { 'all': 0, 'relevance': 1, 'concreteness': 2, 'constructive': 3 };
        const buttons = document.querySelectorAll('.switch-btn');
        if (buttons[modeButtons[mode]]) {
            buttons[modeButtons[mode]].classList.add('active');
        }

        generateGraph(rawData, mode, hwNames);
    }

    // Make globally accessible
    window.updateGraphMode = updateGraphMode;

    // ========================================
    // Student Review Summary Functions
    // ========================================
    
    // Store all student data for filtering
    let allStudentSummaryData = [];
    
    // Render Student Review Summary
    function renderStudentSummary(data, hwKeys) {
        const container = document.getElementById('studentSummaryContainer');
        if (!container) return;
        
        // Collect all student data
        const studentMap = new Map();
        
        hwKeys.forEach(hwName => {
            const hwData = data[hwName] || [];
            hwData.forEach(assignment => {
                const reviewer = assignment.Reviewer_Name || assignment.reviewer;
                const author = assignment.Author_Name || assignment.author;
                
                // Initialize reviewer if not exists
                if (reviewer && !studentMap.has(reviewer)) {
                    studentMap.set(reviewer, {
                        id: reviewer,
                        reviewsGiven: {},      // Reviews this student gave to others
                        reviewsReceived: {},   // Reviews this student received from others
                        totalGiven: 0,
                        totalReceived: 0,
                        assignedTasks: 0,
                        completedTasks: 0,
                        labels: { relevance: 0, concreteness: 0, constructive: 0 }
                    });
                }
                
                // Initialize author if not exists
                if (author && author !== "NULL" && !studentMap.has(author)) {
                    studentMap.set(author, {
                        id: author,
                        reviewsGiven: {},
                        reviewsReceived: {},
                        totalGiven: 0,
                        totalReceived: 0,
                        assignedTasks: 0,
                        completedTasks: 0,
                        labels: { relevance: 0, concreteness: 0, constructive: 0 }
                    });
                }
                
                // Process reviewer's given reviews
                if (reviewer) {
                    const reviewerStudent = studentMap.get(reviewer);
                    
                    // Initialize homework entry if not exists
                    if (!reviewerStudent.reviewsGiven[hwName]) {
                        reviewerStudent.reviewsGiven[hwName] = [];
                    }
                    
                    reviewerStudent.assignedTasks++;
                    
                    // Process rounds for reviews given
                    if (assignment.Round && assignment.Round.length > 0) {
                        let hasValidFeedback = false;
                        assignment.Round.forEach(round => {
                            const feedback = round.Feedback || round.feedback || "";
                            if (feedback.trim()) {
                                hasValidFeedback = true;
                                reviewerStudent.totalGiven++;
                                
                                // Get labels
                                const relevance = round.Relevance || round.relevance || 0;
                                const concreteness = round.Concreteness || round.concreteness || 0;
                                const constructive = round.Constructive || round.constructive || 0;
                                
                                if (relevance === 1) reviewerStudent.labels.relevance++;
                                if (concreteness === 1) reviewerStudent.labels.concreteness++;
                                if (constructive === 1) reviewerStudent.labels.constructive++;
                                
                                reviewerStudent.reviewsGiven[hwName].push({
                                    to: author || "Unknown",
                                    feedback: feedback,
                                    time: round.Time || round.time || "",
                                    relevance,
                                    concreteness,
                                    constructive
                                });
                                
                                // Also add to author's received reviews
                                if (author && author !== "NULL" && studentMap.has(author)) {
                                    const authorStudent = studentMap.get(author);
                                    if (!authorStudent.reviewsReceived[hwName]) {
                                        authorStudent.reviewsReceived[hwName] = [];
                                    }
                                    authorStudent.totalReceived++;
                                    authorStudent.reviewsReceived[hwName].push({
                                        from: reviewer,
                                        feedback: feedback,
                                        time: round.Time || round.time || "",
                                        relevance,
                                        concreteness,
                                        constructive
                                    });
                                }
                            }
                        });
                        if (hasValidFeedback) reviewerStudent.completedTasks++;
                    }
                }
            });
        });
        
        // Convert to array
        allStudentSummaryData = Array.from(studentMap.values());
        
        // Update statistics
        updateSummaryStats(allStudentSummaryData);
        
        // Render student cards
        renderStudentCards(allStudentSummaryData, hwKeys);
        
        // Setup event listeners for filtering
        setupSummaryFilters(hwKeys);
    }
    
    // Update summary statistics
    function updateSummaryStats(students) {
        const totalStudents = students.length;
        const totalGiven = students.reduce((sum, s) => sum + s.totalGiven, 0);
        const totalReceived = students.reduce((sum, s) => sum + s.totalReceived, 0);
        const avgParticipation = totalStudents > 0 
            ? students.reduce((sum, s) => sum + (s.assignedTasks > 0 ? s.completedTasks / s.assignedTasks : 0), 0) / totalStudents * 100 
            : 0;
        const avgQuality = totalGiven > 0
            ? students.reduce((sum, s) => sum + s.labels.relevance + s.labels.concreteness + s.labels.constructive, 0) / (totalGiven * 3) * 100
            : 0;
        
        document.getElementById('totalStudents').textContent = totalStudents;
        document.getElementById('totalReviews').textContent = totalGiven.toLocaleString();
        document.getElementById('avgParticipation').textContent = avgParticipation.toFixed(1) + '%';
        document.getElementById('avgQuality').textContent = avgQuality.toFixed(1) + '%';
    }
    
    // Render student cards
    function renderStudentCards(students, hwKeys) {
        const container = document.getElementById('studentSummaryContainer');
        if (!container || students.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="icon">üì≠</div>
                    <h3>No students found</h3>
                    <p>Try adjusting your search or filter criteria.</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = students.map(student => {
            const participationRate = student.assignedTasks > 0 
                ? (student.completedTasks / student.assignedTasks * 100).toFixed(1) 
                : 0;
            
            // Get homework tabs with reviews (either given or received)
            const hwWithActivity = hwKeys.filter(hw => 
                (student.reviewsGiven[hw] && student.reviewsGiven[hw].length > 0) ||
                (student.reviewsReceived[hw] && student.reviewsReceived[hw].length > 0)
            );
            const activeHw = hwWithActivity[0] || hwKeys[0];
            
            return `
                <div class="student-card" data-student-id="${student.id}">
                    <div class="student-card-header">
                        <div class="student-info">
                            <h3>üë§ ${student.id}</h3>
                            <div class="student-meta">
                                üì§ ${student.totalGiven} given | üì• ${student.totalReceived} received
                            </div>
                        </div>
                        <div class="student-stats-mini">
                            <div class="mini-stat">
                                <div class="value">${participationRate}%</div>
                                <div class="label">Participation</div>
                            </div>
                            <div class="mini-stat given">
                                <div class="value">${student.totalGiven}</div>
                                <div class="label">Given</div>
                            </div>
                            <div class="mini-stat received">
                                <div class="value">${student.totalReceived}</div>
                                <div class="label">Received</div>
                            </div>
                        </div>
                    </div>
                    <div class="hw-tabs">
                        ${hwKeys.map(hw => {
                            const givenCount = student.reviewsGiven[hw]?.length || 0;
                            const receivedCount = student.reviewsReceived[hw]?.length || 0;
                            return `
                                <button class="hw-tab ${hw === activeHw ? 'active' : ''}" 
                                        data-hw="${hw}" data-student="${student.id}">
                                    ${hw} <span class="review-count">${givenCount}/${receivedCount}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="hw-review-content" data-student="${student.id}">
                        ${renderReviewsGivenReceived(student.reviewsGiven[activeHw] || [], student.reviewsReceived[activeHw] || [])}
                    </div>
                </div>
            `;
        }).join('');
        
        // Add tab click events
        container.querySelectorAll('.hw-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const hw = this.dataset.hw;
                const studentId = this.dataset.student;
                const card = container.querySelector(`.student-card[data-student-id="${studentId}"]`);
                const student = allStudentSummaryData.find(s => s.id === studentId);
                
                if (card && student) {
                    // Update active tab
                    card.querySelectorAll('.hw-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update content
                    const content = card.querySelector('.hw-review-content');
                    content.innerHTML = renderReviewsGivenReceived(student.reviewsGiven[hw] || [], student.reviewsReceived[hw] || []);
                }
            });
        });
    }
    
    // Render reviews given and received in two columns
    function renderReviewsGivenReceived(given, received) {
        return `
            <div class="reviews-dual-panel">
                <div class="reviews-panel given-panel">
                    <div class="panel-header">
                        <span class="panel-icon">üì§</span>
                        <span class="panel-title">Reviews Given</span>
                        <span class="panel-count">${given.length}</span>
                    </div>
                    <div class="reviews-list">
                        ${given.length === 0 ? `
                            <div class="no-reviews">
                                <div class="icon">üìù</div>
                                <p>No reviews given</p>
                            </div>
                        ` : given.map(review => {
                            let primaryLabel = '';
                            let labelClass = '';
                            if (review.constructive === 1) { primaryLabel = 'Constructive'; labelClass = 'constructive'; }
                            else if (review.relevance === 1) { primaryLabel = 'Relevance'; labelClass = 'relevance'; }
                            else if (review.concreteness === 1) { primaryLabel = 'Concreteness'; labelClass = 'concreteness'; }
                            
                            return `
                                <div class="review-item ${labelClass}">
                                    <div class="review-header">
                                        <span class="reviewer-info">‚û°Ô∏è To: ${review.to}</span>
                                        <div class="review-meta">
                                            ${primaryLabel ? `<span class="review-label ${labelClass}">${primaryLabel}</span>` : ''}
                                        </div>
                                    </div>
                                    <div class="review-text">${escapeHtml(review.feedback)}</div>
                                    ${review.time ? `<div class="review-time-footer">${review.time}</div>` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                <div class="reviews-panel received-panel">
                    <div class="panel-header">
                        <span class="panel-icon">üì•</span>
                        <span class="panel-title">Reviews Received</span>
                        <span class="panel-count">${received.length}</span>
                    </div>
                    <div class="reviews-list">
                        ${received.length === 0 ? `
                            <div class="no-reviews">
                                <div class="icon">üì¨</div>
                                <p>No reviews received</p>
                            </div>
                        ` : received.map(review => {
                            let primaryLabel = '';
                            let labelClass = '';
                            if (review.constructive === 1) { primaryLabel = 'Constructive'; labelClass = 'constructive'; }
                            else if (review.relevance === 1) { primaryLabel = 'Relevance'; labelClass = 'relevance'; }
                            else if (review.concreteness === 1) { primaryLabel = 'Concreteness'; labelClass = 'concreteness'; }
                            
                            return `
                                <div class="review-item ${labelClass}">
                                    <div class="review-header">
                                        <span class="reviewer-info">‚¨ÖÔ∏è From: ${review.from}</span>
                                        <div class="review-meta">
                                            ${primaryLabel ? `<span class="review-label ${labelClass}">${primaryLabel}</span>` : ''}
                                        </div>
                                    </div>
                                    <div class="review-text">${escapeHtml(review.feedback)}</div>
                                    ${review.time ? `<div class="review-time-footer">${review.time}</div>` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            </div>
        `;
    }
    
    // Escape HTML for security
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Setup filter event listeners
    function setupSummaryFilters(hwKeys) {
        const searchInput = document.getElementById('studentSearch');
        const hwFilter = document.getElementById('hwFilter');
        const sortBy = document.getElementById('sortBy');
        
        function applyFilters() {
            let filtered = [...allStudentSummaryData];
            
            // Search filter
            const searchTerm = searchInput?.value.toLowerCase() || '';
            if (searchTerm) {
                filtered = filtered.filter(s => s.id.toLowerCase().includes(searchTerm));
            }
            
            // Homework filter
            const hwValue = hwFilter?.value || 'all';
            if (hwValue !== 'all') {
                filtered = filtered.filter(s => 
                    (s.reviewsGiven[hwValue] && s.reviewsGiven[hwValue].length > 0) ||
                    (s.reviewsReceived[hwValue] && s.reviewsReceived[hwValue].length > 0)
                );
            }
            
            // Sorting
            const sortValue = sortBy?.value || 'name';
            filtered.sort((a, b) => {
                switch(sortValue) {
                    case 'reviews':
                        return (b.totalGiven + b.totalReceived) - (a.totalGiven + a.totalReceived);
                    case 'participation':
                        const rateA = a.assignedTasks > 0 ? a.completedTasks / a.assignedTasks : 0;
                        const rateB = b.assignedTasks > 0 ? b.completedTasks / b.assignedTasks : 0;
                        return rateB - rateA;
                    default:
                        return a.id.localeCompare(b.id);
                }
            });
            
            updateSummaryStats(filtered);
            renderStudentCards(filtered, hwKeys);
        }
        
        if (searchInput) searchInput.addEventListener('input', applyFilters);
        if (hwFilter) hwFilter.addEventListener('change', applyFilters);
        if (sortBy) sortBy.addEventListener('change', applyFilters);
    }

    // Initialize on DOM ready
    document.addEventListener("DOMContentLoaded", function () {
        // Show loading progress
        const loadingText = document.getElementById('loading-text');
        const loadingProgress = document.getElementById('loading-progress');
        const progressBar = document.getElementById('progress-bar');
        
        function updateProgress(percent, text) {
            if (loadingText) loadingText.textContent = text;
            if (loadingProgress) loadingProgress.style.display = 'block';
            if (progressBar) progressBar.style.width = percent + '%';
        }
        
        // Load summary data (fast) or fall back to full data
        async function loadData() {
            updateProgress(10, '‚è≥ Checking for data...');
            
            // Try summary first (much faster - ~400KB vs 14MB)
            try {
                updateProgress(20, '‚è≥ Loading summary data...');
                if (response.ok) {
                    updateProgress(50, '‚è≥ Parsing summary...');
                    const summaryData = await response.json();
                    console.log('‚úÖ Loaded summary data (fast mode)');
                    updateProgress(80, '‚è≥ Converting to display format...');
                    
                    // Convert summary format to display format
                    const displayData = convertSummaryToDisplayFormat(summaryData);
                    updateProgress(100, '‚úÖ Ready!');
                    return { data: displayData, source: 'summary', summaryData };
                }
            } catch (e) {
                console.log('Summary not available, loading full data...');
            }
            
            // Fall back to full data (slower)
            updateProgress(30, '‚è≥ Loading full data (this may take a moment)...');
            const response = await fetch("./output/final_result.json");
            if (response.ok) {
                updateProgress(60, '‚è≥ Parsing large JSON file...');
                const data = await response.json();
                updateProgress(100, '‚úÖ Ready!');
                console.log('‚úÖ Loaded full data');
                return { data, source: 'full' };
            }
            
            throw new Error("No data source available");
        }
        
        // Convert summary format to the format expected by visualization
        function convertSummaryToDisplayFormat(summary) {
            const result = {};
            
            for (const [hwName, hwData] of Object.entries(summary)) {
                result[hwName] = [];
                
                // Check if we have actual edges in the summary
                const edges = hwData.edges || [];
                
                if (edges.length > 0) {
                    // Use actual edges from the data
                    const edgeMap = new Map();  // Group edges by reviewer
                    
                    edges.forEach(edge => {
                        if (!edgeMap.has(edge.from)) {
                            edgeMap.set(edge.from, []);
                        }
                        edgeMap.get(edge.from).push(edge);
                    });
                    
                    // Create assignment records from edges
                    for (const [reviewerId, reviewerEdges] of edgeMap) {
                        const reviewerData = hwData.reviewers[reviewerId] || {};
                        
                        reviewerEdges.forEach(edge => {
                            const assignment = {
                                Assignment: hwName,
                                Reviewer_Name: reviewerId,
                                Author_Name: edge.to,
                                Round: []
                            };
                            
                            // Generate rounds based on edge data
                            const roundCount = edge.rounds || 1;
                            const validFeedbacks = Math.min(roundCount, reviewerData.validFeedbacks || 0);
                            
                            for (let i = 0; i < roundCount; i++) {
                                const sampleFeedback = reviewerData.sampleFeedbacks?.[i % (reviewerData.sampleFeedbacks?.length || 1)];
                                assignment.Round.push({
                                    Feedback: i < validFeedbacks ? (sampleFeedback?.feedback || "Valid feedback") : "",
                                    Relevance: i < (reviewerData.relevance || 0) ? 1 : 0,
                                    Concreteness: i < (reviewerData.concreteness || 0) ? 1 : 0,
                                    Constructive: i < (reviewerData.constructive || 0) ? 1 : 0
                                });
                            }
                            
                            result[hwName].push(assignment);
                        });
                    }
                    
                    // Also add reviewers who have no edges (no author data)
                    for (const [reviewerId, reviewerData] of Object.entries(hwData.reviewers)) {
                        if (!edgeMap.has(reviewerId) && reviewerData.validFeedbacks > 0) {
                            // Reviewer with feedback but no author - create self-referencing record
                            const assignment = {
                                Assignment: hwName,
                                Reviewer_Name: reviewerId,
                                Author_Name: "NULL",
                                Round: []
                            };
                            
                            for (let i = 0; i < reviewerData.validFeedbacks; i++) {
                                const sampleFeedback = reviewerData.sampleFeedbacks?.[i % (reviewerData.sampleFeedbacks?.length || 1)];
                                assignment.Round.push({
                                    Feedback: sampleFeedback?.feedback || "Valid feedback",
                                    Relevance: i < reviewerData.relevance ? 1 : 0,
                                    Concreteness: i < reviewerData.concreteness ? 1 : 0,
                                    Constructive: i < reviewerData.constructive ? 1 : 0
                                });
                            }
                            
                            result[hwName].push(assignment);
                        }
                    }
                } else {
                    // No edges - create records from reviewers only (old format fallback)
                    for (const [reviewerId, reviewerData] of Object.entries(hwData.reviewers)) {
                        // Create a simplified assignment record for each reviewer
                        const assignment = {
                            Assignment: hwName,
                            Reviewer_Name: reviewerId,
                            Author_Name: reviewerData.authors[0] || "NULL",
                            Round: []
                        };
                        
                        // Generate synthetic rounds based on summary stats
                        for (let i = 0; i < reviewerData.validFeedbacks; i++) {
                            const sampleFeedback = reviewerData.sampleFeedbacks[i % reviewerData.sampleFeedbacks.length];
                            assignment.Round.push({
                                Feedback: sampleFeedback ? sampleFeedback.feedback : "Valid feedback",
                                Relevance: i < reviewerData.relevance ? 1 : 0,
                                Concreteness: i < reviewerData.concreteness ? 1 : 0,
                                Constructive: i < reviewerData.constructive ? 1 : 0
                            });
                        }
                        
                        // Add edges to all authors this reviewer reviewed
                        if (reviewerData.authors.length > 0) {
                            reviewerData.authors.forEach(author => {
                                result[hwName].push({
                                    ...assignment,
                                    Author_Name: author
                                });
                            });
                        } else {
                            // If no authors, still add the reviewer
                            result[hwName].push(assignment);
                        }
                    }
                }
            }
            
            return result;
        }
        
        loadData()
            .then(({ data, source, summaryData }) => {
                rawData = data;
                window.summaryData = summaryData;  // Store for potential use
                
                // Update data info
                const hwKeys = Object.keys(data).sort();
                let totalAssignments = 0;
                let totalFeedbacks = 0;
                
                if (source === 'summary' && summaryData) {
                    // Use stats from summary
                    hwKeys.forEach(hw => {
                        if (summaryData[hw] && summaryData[hw].stats) {
                            totalAssignments += summaryData[hw].stats.totalAssignments;
                            totalFeedbacks += summaryData[hw].stats.totalFeedbacks;
                        }
                    });
                } else {
                    // Count from full data
                    hwKeys.forEach(hw => {
                        totalAssignments += data[hw].length;
                        data[hw].forEach(a => {
                            totalFeedbacks += (a.Round || []).length;
                        });
                    });
                }
                
                const sourceLabel = source === 'summary' ? '‚ö° Fast Mode' : 'üì¶ Full Data';
                document.getElementById('data-info').innerHTML = 
                    `‚úÖ Loaded: <strong>${hwKeys.length}</strong> assignments | ` +
                    `<strong>${totalAssignments}</strong> records | ` +
                    `<strong>${totalFeedbacks.toLocaleString()}</strong> reviews (${sourceLabel})`;
                
                currentHW = [...hwKeys];
                
                // Generate select options dynamically
                const hwSelect = document.getElementById('hw-select');
                if (hwSelect) {
                    hwSelect.innerHTML = '';
                    hwKeys.forEach(hwKey => {
                        const option = document.createElement('option');
                        option.value = hwKey;
                        option.textContent = hwKey;
                        option.selected = true;
                        hwSelect.appendChild(option);
                    });
                }
                
                // Initialize homework filter dropdown
                const hwFilter = document.getElementById('hwFilter');
                if (hwFilter) {
                    hwFilter.innerHTML = '<option value="all">All Assignments</option>';
                    hwKeys.forEach(hwKey => {
                        const option = document.createElement('option');
                        option.value = hwKey;
                        option.textContent = hwKey;
                        hwFilter.appendChild(option);
                    });
                }
                
                updateGraphMode('all', currentHW);
                
                // Render Student Review Summary
                renderStudentSummary(data, hwKeys);
            })
            .catch(error => {
                console.error("Failed to load JSON:", error);
                document.getElementById('data-info').innerHTML = 
                    `‚ùå No data available. <a href="/">Upload CSV and run pipeline</a>`;
            });

        // GO button event
        document.getElementById('hw-apply-btn').addEventListener('click', () => {
            const select = document.getElementById('hw-select');
            const selectedHWs = Array.from(select.selectedOptions).map(opt => opt.value);
            if (selectedHWs.length === 0) {
                alert("Please select at least one assignment!");
                return;
            }
            currentHW = [...selectedHWs];
            updateGraphMode(currentMode, currentHW);
        });
    });
  </script>

  <!-- Scripts for graph functionality only -->
  <script>
    // Export functions can be added here if needed
  </script>
</body>
</html>
